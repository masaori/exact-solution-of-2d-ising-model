# Task: 033_claim_複素数の積のargがpiのときのarg同士の関係.typ の修正

ステータス：完了

## 対象ファイル
`parts/000_計算公式/033_claim_複素数の積のargがpiのときのarg同士の関係.typ`

## 変更概要
`arg^((-pi, pi])` と `s_((-pi, pi])` を `arg^([0, 2pi))` と `s_([0, 2pi))` に変更する。
このclaimは「積のargがpiのとき」の特殊な場合を扱うので、主張と証明の両方を新しい区間で書き直す必要がある。

## 変更のポイント

### 記号の変更
- `arg^((-pi, pi])` → `arg^([0, 2pi))`
- `s_((-pi, pi])` → `s_([0, 2pi))`

### 不等式の変更
旧: `-pi < ... <= pi` 系
新: `0 <= ... < 2pi` 系

**注意: 等号のつく場所が逆になる。**

### 主張の変更
旧 `(-pi, pi]` 版では `arg^((-pi, pi])(z_1 z_2) = pi` のとき3分岐だったが、新 `[0, 2pi)` 版では `arg^([0, 2pi))(z_1 z_2) = pi` のときの分岐が変わる。

具体的に:
- 旧: `arg^((-pi, pi])` の値域は `(-pi, pi]`、つまり `-pi < arg <= pi`
- 新: `arg^([0, 2pi))` の値域は `[0, 2pi)`、つまり `0 <= arg < 2pi`
- `arg = pi` は新しい区間でも値域内なので、この claim 自体は引き続き意味がある。

ただし:
- 旧版で `arg(z_1) + arg(z_2) = -pi` となるケースは、新しい区間では `arg(z_1) + arg(z_2) = pi` に対応する可能性がある（値域の変化による）。
- 分岐条件を新しい区間 `[0, 2pi)` で全て再導出する必要がある。

### 証明の変更
031のように、`s_([0, 2pi))` を使った証明に書き直す。
各ケースの不等式評価を新しい区間で行い直す。

## 変更の参考例
`parts/000_計算公式/031_claim_複素数の積のarg.typ` で既に同様の変更が行われている。
このファイルでは:
- 旧版（3分岐）がコメントアウトされている
- 新版（2分岐）が `[0, 2pi)` の記法で記述されている

変更前後を比較して、以下を理解すること:
1. 記号 `(-pi, pi]` → `[0, 2pi)` の機械的な置換部分
2. 不等式の向きが逆になる（`<` と `<=` の入れ替え）
3. 分岐条件の再導出が必要な部分（値域の変更により cases が変わる）
4. 証明の各ステップでの不等式評価の変更

## 注意事項
- 1行も省略しないこと。意図的に冗長に全ての計算ステップを明示している。
- 証明の全行を書き直すこと。途中のステップを省略してはならない。
- 旧版の証明のケース分け（a, b, c）が新しい区間ではどうなるか慎重に検討すること。
- 特に `arg(z_1), arg(z_2)` の値域が `(-pi, pi]` から `[0, 2pi)` に変わるため、和 `arg(z_1) + arg(z_2)` の値域も `(-2pi, 2pi]` から `[0, 4pi)` に変わることに注意。
